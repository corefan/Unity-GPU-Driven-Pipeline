// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ClusterCull
#pragma kernel ClearCluster
#pragma kernel ClusterCullOcc
#pragma kernel ObjectCull
#pragma kernel PrepareDispatch
#pragma kernel ClearDispatch
#define COMPUTESHADER
#include "UnityCG.cginc"
#include "CGINC/Procedural.cginc"
float4 planes[PLANECOUNT];
struct ClusterMeshData
{
    float3 extent;
    float3 position;
};
RWStructuredBuffer<ClusterMeshData> clusterBuffer;
RWStructuredBuffer<uint> instanceCountBuffer;
RWStructuredBuffer<uint> resultBuffer;
Texture2D<float> _HizDepthTex;  SamplerState sampler_HizDepthTex;
uint _Count;
float3 _CameraUpVector;
float4x4 _VP;
float PlaneTest(ClusterMeshData info){
    float3 position = info.position;
    float3 extent = info.extent;
    float result = 1;
    [unroll]
    for(int i = 0; i < PLANECOUNT; ++i)
    {
        float4 plane = planes[i];
        float r = dot(position, plane.xyz); 
        float3 absNormal = abs(plane.xyz);
        float f = dot(absNormal, extent);
        result *= ((r - f) < -plane.w) ? 1.0 : 0.0;
    }
    return result;
}

static const float3 extentArray[8] = 
{
    float3(1,1,1),
    float3(1,1,-1),
    float3(1,-1,1),
    float3(1,-1,-1),
    float3(-1,1,1),
    float3(-1,1,-1),
    float3(-1,-1,1),
    float3(-1,-1,-1)
};

float OcclusionTest(ClusterMeshData info)
{
    float3 farPoint = info.position + length(info.extent) * _CameraUpVector;
    float4 centerClipPos = mul(_VP, float4(info.position, 1));
    centerClipPos /= centerClipPos.w;
    float4 farClipPos = mul(_VP, float4(farPoint, 1));
    farClipPos /= farClipPos.w;
    float screenDist = distance(farClipPos.xy, centerClipPos.xy);
    float lodLevel = clamp(log2(screenDist * 64), 0, 7.4);
    [unroll]
    for(uint i = 0; i < 8; ++i)
    {
        float3 worldPoint = info.position + info.extent * extentArray[i];
        float4 clipPos = mul(_VP, float4(worldPoint, 1));
        clipPos /= clipPos.w;
        float2 uv = clipPos.xy;
        uv = uv * 0.5 + 0.5;
        float depth = _HizDepthTex.SampleLevel(sampler_HizDepthTex, uv, lodLevel);
        float dist = Linear01Depth(clipPos.z);
        if(depth > dist) return 1;
    }
    return 0;
}

[numthreads(64, 1, 1)]
void ClusterCull (uint id : SV_DISPATCHTHREADID)
{
    if(id >= _Count) return; 
    ClusterMeshData currentObject = clusterBuffer[id];
    float result =  PlaneTest(currentObject);
    if(result > 0.5){
        uint currentIndex;
        InterlockedAdd(instanceCountBuffer[1], 1, currentIndex);
        resultBuffer[currentIndex] = id;
    }
}

static const uint ClearData[5] = 
{
CLUSTERVERTEXCOUNT,
0,0,0,0
};

[numthreads(5,1,1)]
void ClearCluster(uint id : SV_DISPATCHTHREADID)
{
    instanceCountBuffer[id] = ClearData[id];
}

[numthreads(64, 1, 1)]
void ClusterCullOcc(uint id : SV_DISPATCHTHREADID)
{
    if(id >= _Count) return; 
    ClusterMeshData currentObject = clusterBuffer[id];
    float result =  PlaneTest(currentObject) * OcclusionTest(currentObject);
    if(result > 0.5){
        uint currentIndex;
        InterlockedAdd(instanceCountBuffer[1], 1, currentIndex);
        resultBuffer[currentIndex] = id;
    }
}

struct ObjectMeshData
{
    uint clusterOffset;
    uint clusterCount;
    float3 extent;
    float3x4 localToWorldMatrix;
};

RWStructuredBuffer<ClusterMeshData> allSceneClusterBuffer;
RWStructuredBuffer<ObjectMeshData> allSceneObjectBuffer;
RWStructuredBuffer<uint> dispatchBuffer;
float ObjectFrustum(float3x4 info, float3 extent)
{
    float3 right = float3(info._m00, info._m10, info._m20);
    float3 up = float3(info._m01, info._m11, info._m21);
    float3 forward = float3(info._m02, info._m12, info._m22);
    float3 position = float3(info._m03, info._m13, info._m23);
    float result = 1;
    [unroll]
    for (int i = 0; i < 6; ++i)
    {
        float4 plane = planes[i];
        float r = dot(position, plane.xyz);
        float3 absNormal = float3(abs(dot(plane.xyz, right)), abs(dot(plane.xyz, up)), abs(dot(plane.xyz, forward)));
        float f = dot(absNormal, extent);
        result *= ((r - f) >= -plane.w) ? 0 : 1;
    }
    return result;
}
[numthreads(64, 1, 1)]
void ObjectCull(uint id : SV_DISPATCHTHREADID)
{
    if(id >= _Count) return;
    ObjectMeshData data = allSceneObjectBuffer[id];
    if(ObjectFrustum(data.localToWorldMatrix, data.extent))
    {
        uint currentIndex;
        InterlockedAdd(dispatchBuffer[3], data.clusterCount, currentIndex);
        for(uint i = 0; i < data.clusterCount; ++i)
        {
            clusterBuffer[currentIndex + i] = allSceneClusterBuffer[data.clusterOffset + i];
        }
    }
}

[numthreads(1,1,1)]
void PrepareDispatch()
{
    uint threadCount = dispatchBuffer[3];
    uint threadGroupCount = threadCount / 64;
    if(threadCount % 64 > 0)
    {
        threadGroupCount++;
    }
    dispatchBuffer[0] = threadGroupCount;
}
static const uint ClearDispatchArray[4] = {0,1,1,0};
[numthreads(4,1,1)]
void ClearDispatch(uint id : SV_DISPATCHTHREADID)
{
    dispatchBuffer[id] = ClearDispatchArray[id];
}
/*
1. ClearDispatch ComputeShader.Dispatch(5, 1, 1, 1);
2. ObjectCull ComputeShaderUtility.Dispatch(3, objectCount)
3. PrepareDispatch ComputeShader.Dispatch(4,1,1,1)
4. ClearCluster ComputeShader.Dispatch(1,1,1,1)
5. ClusterCullOcc ComputeShader.DispatchIndirect(2, dispatchBuffer)
*/