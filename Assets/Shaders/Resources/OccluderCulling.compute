// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel Clear
#define PLANECOUNT 6
float4 planes[PLANECOUNT];
uint _Count;
float PlaneTest(float4x4 info)
{
    float3 right = float3(info._m00, info._m10, info._m20);
    float3 up = float3(info._m01, info._m11, info._m21);
    float3 forward = float3(info._m02, info._m12, info._m22);
    float3 position = float3(info._m03, info._m13, info._m23);
    float result = 1;
    [unroll]
    for (int i = 0; i < 6; ++i)
    {
        float4 plane = planes[i];
        float r = dot(position, plane.xyz);
        float3 absNormal = float3(abs(dot(plane.xyz, right)), abs(dot(plane.xyz, up)), abs(dot(plane.xyz, forward)));
        float f = dot(absNormal, 0.5);
        result *= ((r - f) >= -plane.w) ? 0 : 1;
    }
    return result;
}

RWStructuredBuffer<float4x4> allCubeBuffer;
RWStructuredBuffer<uint> instanceCountBuffer;
RWStructuredBuffer<float4x4> resultBuffer;
[numthreads(64,1,1)]
void CSMain (uint id : SV_DispatchThreadID)
{
	if (id >= _Count) return;
    float4x4 info = allCubeBuffer[id];
    if(PlaneTest(info) > 0.5)
    {
        uint index;
        InterlockedAdd(instanceCountBuffer[1], 1, index);
        resultBuffer[index] = info;
    }
}


static const uint ClearData[5] = 
{
36,0,0,0,0
};
[numthreads(5,1,1)]
void Clear(uint id : SV_DISPATCHTHREADID)
{
    instanceCountBuffer[id] = ClearData[id];
}
